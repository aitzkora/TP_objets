#+OPTIONS: tex:t
* Équation de la chaleur
 Le but de ce TP est d'écrire une classe en C++ qui simulera l'équation de la chaleur sur un carré.
** Aspect mathématique 
 L'équation que l'on souhaite résoudre est la suivante

  \partial_{t} u(x,t) - \Delta u(x,t) = 0 

avec les conditions aux bord

   u(x,t) = 1 \forall x \in \partial [0,1]^2. 

En discretisant

   \partial_{t} u(x,t_{k}) \approx (u(x, t_{k} + dt) - u(x, t_{k}))/dt

et
   
   \Delta u(x,y,t)  \approx  \frac{u(x-h_{x}, y,t) + u(x+ h_{x}, y,t) - 2 
   u(x,y,t)}{h_{x}^{2}} 
               + \frac{u(x, y-h_{y},t) + u(x, y + h_{y},t) - 2 
                 u(x,y,t)}{h_{y}^{2}}, 
Par conséquent

   U^{n+1}_{i,j} =  w_{x} (U^{n}_{i-1, j} + U^{n}_{i+1, j} ) + w_{y} 
   (U^{n}_{i,j-1} + U^{n}_{i, j+1}) + d U^{n}_{i,j} 

avec pour

   w_{x} = dt/h_{x}^{2} \qquad,  w_y = dt/h_{y}^{2} ,\qquad  d=1 - 2 w_{x} - 2 w_{y}
  
  Pour cela on aimerait avoir un programme principal du genre
#begin_src c++
#include "Chaleur.hpp"

int main(int argc, char * argv[])
{
    if (argc < 3)
    {
        std::cerr << "usage "  <<argv[0] << " maxIt prec" << std::endl;
    }
    int maxIt = std::atoi(argv[1]);
    double eps = std::atof(argv[2]);
    Chaleur poeleACharbon(1., 1., 100, 100);
    poeleACharbon.initialise(1.0);
    poeleACharbon.resout(maxIt, eps);
    return 0;
}
#end_src

La classe ~Chaleur~ aura donc _a minima_ l'interface suivante
#begin_src c++
class Chaleur {
    public:
        Chaleur(double deltaX, double deltaY, int dimX, int dim, double dt);
        ~Chaleur();
        int resout(int maxIt, double eps);
        void initialise(double valSurLeBord);
};
#end_src
On pourra encoder l'etat de la solution courante de plusieurs façons : 
- soit un double * , qu'il faudra allouer dans le constructeur et liberer dans le destructeur
#begin_src c++
Chaleur::Chaleur(...)
{
...
_sol =  new double [_dimX * _dimY];
...
}

Chaleur::~Chaleur()
{
delete [] _sol;
}
#end_src
- soit un vector<double> de la STL
Dans les deux cas, on aura interet a utiliser un stockage plat, car les pointeurs de pointeurs sont lents en mémoire et
les tableaux bidimensionels `double [DIM1][DIM2]` nécessitent quand a eux de connaître leur taille à la compilation

On aura d'ailleurs interet a stocker les deux etats succesifs `X_n` et `X_n+1` de la solutions dans 2 tableaux differents
dont on pourra faire une copie simple grâce à la fonction `std::copy_n`, par exemple

On peut rajouter des méthodes internes, destinés a sauvegarder la solution à certains pas de temps et a calculer X_{n+1} en fonction de X_n
** 
